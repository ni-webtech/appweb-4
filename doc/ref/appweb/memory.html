<!-- BeginDsi "dsi/head.html" -->
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Embedthis Appweb 4.0.0 Documentation</title>
    <meta name="keywords" content="embedded web server, web server software, embedded HTTP, application web server, 
        embedded server, small web server, HTTP server, library web server, library HTTP, HTTP library" />
    <meta name="description" content="Embedthis Sofware provides commercial and open source embedded web servers for 
        devices and applications." />
	<meta name="robots" content="index,follow" />
	<link href="../../doc.css" rel="stylesheet" type="text/css" />
	<link href="../../print.css" rel="stylesheet" type="text/css" media="print"/>
    <!--[if IE]>
    <link href="../../iehacks.css" rel="stylesheet" type="text/css" />
    <![endif]-->
</head>

<body>
    <div class="top">
        <a class="logo" href="http://appwebserver.org/">&nbsp;</a>
        <div class="topRight">
             <div class="search">
                 <form id="search" method="get" action="http://www.google.com/search" title="Search appwebserver.org">
                     <p>
                        <label for="q" title="Search">Search</label> 
                        <input type="text" id="q" name="q" size="15" maxlength="255" />
                        <input type="submit" id="submit" value="Go" /> 
                        <input type="hidden" name="domains" value="appwebserver.org" /> 
                        <input type="hidden" name="sitesearch" value="appwebserver.org" />
                    </p>
                 </form>
              </div>
            <!--TITLE-->Embedthis Appweb 4.0.0
        </div>
        <div class="crumbs">
            <a href="../../product/index.html">Home</a>
<!-- EndDsi -->
             &gt; <a href="index.html">Programmers Reference</a> &gt; <b>Architecture</b>
        </div>
    </div>
    <div class="content">
        <div class="contentRight">
            <h1>Quick Nav</h1>
            <ul>
                <li><a href="#overview">Overview</a></li>
                <li><a href="#allocator">Allocator</a></li>
                <li><a href="#errors">Error Handling</a></li>
                <li><a href="#collector">Garbage Collector</a></li>
                <li><a href="#phases">Collection Phases</a></li>
                <li><a href="#marking">Marking Blocks</a></li>
                <li><a href="#alloc">Allocating Memory</a></li>
                <li><a href="#managers">Managers</a></li>
            </ul>
            <h1>See Also</h1>
            <ul>
                <li><a href="multithread.html">Multithreaded</a></li>
                <li><a href="architecture.html">Appweb Architecture</a></li>
                <li><a href="../../guide/appweb/overview.html">User Guide Overview</a></li>
                <li><a href="../../guide/appweb/users/authorization.html">Authorization</a></li>
                <li><a href="../../guide/appweb/users/configuration.html">Configuration</a></li>
                <li><a href="../../guide/appweb/users/configuration.html#directives">Configuration Directives</a></li>
                <li><a href="../../guide/appweb/users/stages.html">Pipeline Stages</a></li>
                <li><a href="../../guide/appweb/users/client.html">HTTP Client</a></li>
                <li><a href="../../guide/appweb/users/modules.html">Loadable Modules</a></li>
                <li><a href="../../guide/appweb/users/ports.html">Ports and Binding</a></li>
                <li><a href="../../guide/appweb/users/ssl.html">Secure Sockets Layer</a></li>
                <li><a href="../../guide/appweb/users/vhosts.html">Virtual Hosts</a></li>
            </ul>
        </div>
        <div class="contentLeft">
            <h1>MPR Memory Allocator</h1>
            <a name="overview"></a>
            <h2>Overview</h2>
            <p>Appweb provides an application-specific memory allocator to use instead of malloc. This allocator is 
            part of the Multithreaded Portable Runtime (MPR) and is tailored to the needs of embedded applications.
            It is faster than most general purpose malloc allocators for these workloads. It is deterministic and 
            allocates and frees memory in constant time O(1). It exhibits very low fragmentation and accurate 
            coalescing.</p>
            <p>The allocator uses a garbage collector for locating unused memory. The collector is a generational, 
            cooperative and non-compacting collector.  The use of a garbage collector is somewhat unusual in a C program. 
            However, garbage collection it is especially well suited for long running applications like a web server,
            as it eliminates most memory leaks. Unlike traditional memory allocation where <em>free</em> must be called
            to release memory, Appweb uses the opposite approach where memory that must be retained, needs 
            to be actively managed to 
            prevent garbage collection. This means that a <em>managed reference</em> must be held for all active memory.</p>
            <a name="allocator"></a>
            <h2>Allocator</h2>
            <p>The allocator is optimized for frequent allocations of small blocks (&lt; 4K). It 
            uses a scheme of free queues for fast allocation. Memory allocations are aligned on 16 byte boundaries on 64-bit 
            systems and otherwise on 8 byte boundaries. It will return chunks of unused memory back to the O/S.</p>
            <h3>Appweb 3 Allocator</h3>
            <p>Appweb 3 used memory contexts for all memory allocations. This required many APIs to have a memory context
            as the first parameter. Appweb 4 does not require this and these APIs have removed the memory context 
            parameter.</p>
            <a name="errors"></a>
            <h2>Error Handling</h2>
            <p> It is difficult for programmers to consistently
            check the result of every API call that can fail due to memory allocation errors. Calls such as strdup and 
            asprintf are often assumed to succeed, but they can, and do fail when memory is depleted.</p>
            <p>A better approach is to proactively detect and handle memory allocation errors in one place.
            The MPR allocator handles memory allocation errors globally. It has
            has a configurable memory redline limit and memory depletion policy handler. 
            Appweb configures this memory limit so that memory depletion can be proactively detected and 
            handled before memory allocations actually fail.
            When memory usage exceeds a pre-configured redline value, the depletion handler is invoked. 
            The application can then determine what action to take. Appweb will restart automatically in such 
            circumstances.</p>
            <a name="collector"></a>
            <h2>Garbage Collection</h2>
            <p>The MPR garbage collector will run periodically to reclaim unused memory and potentially return 
            that memory to the
            Operating System. The collector runs in its own thread, but is cooperative, in that each other thread must 
            yield to the collector before memory can be reclaimed. Worker threads yield to the collector
            by calling the <em>mprYield</em> API.
            This strategy permits worker threads to allocate temporary memory without fear. The memory will not be 
            prematurely collected until the worker explicitly acknowledges and yields to the collector by 
            calling <em>mprYield</em>.</p>
            <p>To prevent collection of a memory block and retain the block over a yield point, the application must 
            hold a managed reference for the block. A managed reference, is a reference to an allocated block that 
            will be marked as active during a collection cycle by the Owning Blocks manager function. Manager functions
            are defined when allocating blocks that will hold managed references.</p>
            <a name="phases"></a>
            <h3>Collection Phases</h3>
            <p>The collector reclaims memory in three phases: Wait, Mark and Sweep. The Wait phase waits for all
            threads to yield. This quiesces the system for reliable collection. NOTE: this does not mean that all 
            request activity must cease. Rather, pre-determined rendezvous yield points are inserted in key locations 
            in the Appweb HTTP processing engine.</p>
            <p>The Mark phase traverses memory and marks all blocks that are 
            currently being used. The Sweep phase finally reclaims all blocks that are not marked.</p>
            <a name="marking"></a>
            <h3>Marking Blocks</h3>
            <p>The Mark phase beings with a set of known root memory blocks. The ultimate root is the Mpr object 
            returned from the <em>mprCreate</em> API. However, other roots can be added at any time 
            via <em>mprAddRoot</em>. For each root,
            the collector invokes the manager function defined when the block was allocated. It is the responsibility of
            that manager function to call <em>mprMark</em> on every managed reference owned by the block. 
            The mprMark function will then invoke the manager for these managed references and so on.
            In this manner, managed memory forms a tree from the roots to the leaves and the mark phase visits every 
            managed block currently in use.</p>
            <a name="alloc"></a>
            <h3>Allocating Memory</h3>
            <p>Managers are defined when allocating a block of memory. For example, this code will allocate a block
            that will contain a managed reference to an allocated string:</p>
<pre>
char **block = mprAllocObj(char*, manageBlock);
*block = sclone("Hello World");
</pre>
            <p>This will allocate a block sufficient to store one character pointer and will define the manageBlock 
            function as the manager for managed references in that block. The sclone function allocates a string block
            and copies the string argument. The mprAllocObj function is used to allocate structures with managers. Use
            mprAllocMem to allocate a block of memory and reserve room for a manager function. Then use mprSetManager to
            define a manager function.</p>
            <a name="managers"></a>
            <h3>Managers</h3>
            <p>A manager function is invoked by the collector during each collector Mark phase of the collection cycle.
            The manager is passed a reference to the block and a flags word. The flags are set to either MPR_MANAGE_MARK
            during the Mark phase and to MPR_MANAGE_FREE if the collector determines the block is to be freed.</p> 
<pre>
void manageBlock(char *ptr, int flags) 
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(*ptr);
    } else if (flags & MPR_MANAGE_FREE) {
        /* Custom code when the block is freed */
    }
}
</pre>
            <p>A common technique it to define a top level application structure which will be the root memory block
            for the entire application. Store top level managed references in this block and call mprAddRoot to define
            it as a root block.</p>
        </div>
    </div>
<!-- BeginDsi "dsi/bottom.html" -->

	<div class="bottom">
		<p class="footnote"> 
            <a href="../../product/copyright.html" >&copy; Embedthis Software LLC, 2003-2011. 
            All rights reserved. Embedthis, ESP, Ejscript and Appweb are trademarks of Embedthis Software LLC.</a>
		</p>
	</div>
<!-- EndDsi -->
</body>
</html>
