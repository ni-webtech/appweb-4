<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- BeginDsi "dsi/head.html" -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Embedthis Ejscript 2.0.0 Documentation</title>
    <meta name="keywords" content="Ejscript, JavaScript, ECMAScript, Server-Side JavaScript, Dynamic languages, 
        Embedded, AJAX, language"/>
	<meta name="description" content="Ejscript -- Embedded Server-Side JavaScript Language."/>
	<meta name="robots" content="index,follow" />
	<link href="../../../doc.css" rel="stylesheet" type="text/css" />
	<link href="../../../print.css" rel="stylesheet" type="text/css" media="print"/>
    <!--[if IE]>
    <link href="../../../iehacks.css" rel="stylesheet" type="text/css" />
    </![endif]-->
</head>

<body>
    <div class="top">
        <a class="logo"  href="http://www.ejscript.org/">&nbsp;</a>
        <div class="topRight">
             <div class="search">
                 <form method="get" action="http://www.google.com/search" title="Search www.embedthis.com">
                     <p>
                        <label title="Search">Search</label> 
                        <input type="text" id="q" name="q" size="15" maxlength="255" />
                        <input type="submit" id="submit" value="Go" /> 
                        <input type="hidden" name="domains" value="embedthis.com" /> 
                        <input type="hidden" name="sitesearch" value="embedthis.com" />
                    </p>
                 </form>
              </div>
            <!--TITLE-->Embedthis Ejscript 2.0.0
        </div>
        <div class="crumbs">
            <a href="../../../product/index.html">Home</a>
<!-- EndDsi -->
             &gt; <a href="gettingStarted.html">Getting Started</a> &gt; <b>Language Tour</b>
        </div>
    </div>
    <div class="content">
        <div class="contentRight">
            <h2>Quick Nav</h2>
            <ul>
                <li><a href="#shell">Running the Shell</a></li>
                <li><a href="#hello">Hello World</a></li>
                <li><a href="#names">Names</a></li>
                <li><a href="#numbers">Numbers and Expressions</a></li>
                <li><a href="#functions">Functions</a></li>
                <li><a href="#classes">Classes</a></li>
                <li><a href="#objects">Objects</a></li>
                <li><a href="#hashes">Hashes</a></li>
                <li><a href="#arrays">Arrays</a></li>
                <li><a href="#types">Type Annotations</a></li>
                <li><a href="#statements">Statements</a></li>
                <li><a href="#iteration">Iteration</a></li>
                <li><a href="#scope">Scope</a></li>
                <li><a href="#namespaces">Namespaces</a></li>
                <li><a href="#closures">Closures</a></li>
                <li><a href="#exceptions">Exceptions</a></li>
                <li><a href="#library">Script Library</a></li>
            </ul>
<!-- BeginDsi "dsi/ejsGuideSeeAlso.html" -->
        <h2>See Also</h2>
        <ul>
          <li><a href="../../../guide/ejs/language/index.html">Language Guide</a></li>
          <li><a href="../../../guide/ejs/programmers/index.html">Programmers Guide</a></li>
          <li><a href="../../../guide/ejs/solutions/index.html">Solution Guide</a></li>
          <li><a href="../../../guide/ejs/users/index.html">User Guide</a></li>
        </ul>
<!-- EndDsi -->
        </div>
        <div class="contentLeft">
            <h1>Ejscript Language Tour</h1>
            <p>This will be a quick tour of Ejscript to give you a feel for the language, its constructs and
            capabilities.</p>
            <p>First make sure you have read the <a href="quickStart.html">Quick Start</a> and that you have Ejscript
            installed on your system so you can type along as we go. This tour will work with the Ejscript <a href=
            "shell.html">command shell</a> to run small scripts.</p>
            <p>In this documentation, command sessions are presented in blue boxes. Output from the system is
            highlighted in yellow. Bold yellow is used to highlight some output of specific interest. You can type
            these examples interactively into the shell or you can edit a file and run the file using "ejs
            filename".</p>
            <h2><a name="shell" id="shell"></a>Running the Shell</h2>
            <p>Type <strong>ejs</strong> to run the Ejscript command shell. Once inside the shell, you can type
            Ejscript programs for immediate execution.</p>
            <pre>
<font color="#FFFF00">home&gt;</font> ejs
<font color="#FFFF00">ejs-0&gt;</font>
</pre>
            <h2><a name="hello" id="hello"></a>Hello World</h2>
            <p>Every tour beings with the obligatory "Hello World" program. To print output, we use the
            <strong>print</strong> function.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> print("Hello World")
<strong><font color="#FFFF00">Hello World
</font></strong>
</pre>
            <p>The ejs shell will also echo the last result to the console, so when inside the shell, the minimal hello
            world program is just the string "Hello World" itself.</p>
            <pre>
ejs-0&gt; "Hello World"<strong><font color="#FFFF00">
Hello World</font></strong>
</pre>
            <h2><a name="names" id="names"></a>Names</h2>
            <p>In Ejscript, variable and function names must begin with an alphabetic underscore "_" or dollar "$"
            character. The rest of the name may contain any number of alphabetic, underscore, dollar or numeric
            characters. These are all valid names with declarations and assignments.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> var x
<font color="#FFFF00">ejs-0&gt;</font> var $y
<font color="#FFFF00">ejs-0&gt;</font> var __myColor
<font color="#FFFF00">ejs-0&gt;</font> function print43() {}
</pre>
            <h2><a name="numbers" id="numbers"></a>Numbers and Expressions</h2>
            <p>You can use the ejs shell to calculate simple arithmetic:</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> 1 + 2
<font color="#FFFF00"><strong>3</strong></font>
<font color="#FFFF00">ejs-0&gt;</font> 1.5 * 2.5
<font color="#FFFF00"><strong>3.75</strong></font>
</pre>
            <p>or print as hex:</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> "%x" % 50000
<font color="#FFFF00"><strong>c350</strong></font> 
</pre>
            <h2><a name="functions" id="functions"></a>Functions</h2>
            <p>Typing code into an interpreter is fun, but frequently you want to reuse some code again and again. For
            that we create functions which are reusable procedures.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> function add(x, y) {
<font color="#FFFF00">ejs-2&gt;</font>   return x + y
<font color="#FFFF00">ejs-2&gt;</font> }
                    
</pre>
            <p>To call a function:</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> add(1,2)
<font color="#FFFF00"><strong>3</strong></font>
<font color="#FFFF00">ejs-0&gt;</font> add(5,5)
<font color="#FFFF00"><strong>10</strong></font>
</pre>
            <p>Expecially useful, is that functions are objects and you can assign them to variables and pass them as
            arguments to other functions. More on this later.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> var math = function (x, y) { return x + y; }
<font color="#FFFF00">ejs-0&gt;</font> math(100, 200)
<font color="#FFFF00"><strong>300</strong></font>
</pre>
            <h2><a name="classes" id="classes"></a>Classes</h2>
            <p>Classes are a new addition to JavaScript that follows a very familiar paradigm. Classes enable us to
            group variables and a set of functions to operate on those variables. More importantly, we can create many
            object instances of a class.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> class Shape {
<font color="#FFFF00">ejs-2&gt;</font>   var height
<font color="#FFFF00">ejs-2&gt;</font>   var width
<font color="#FFFF00">ejs-2&gt;</font>   function Shape(length, depth) {
<font color="#FFFF00">ejs-2&gt;</font>     height = length
<font color="#FFFF00">ejs-2&gt;</font>     width = depth
<font color="#FFFF00">ejs-2&gt;</font>   }
<font color="#FFFF00">ejs-2&gt;</font> }
</pre>
            <p>This code defines a new class called Shape. It has two property variables called height and width. These
            are created per object instance. We also have a special function called Shape(). This is a constructor and
            is called when we create a new shape object. We can now create as many shapes as we like via the
            <strong>new</strong> keyword. Each time, the constructor is called to initialize the shape.</p>
            <pre>
<font color="#FFFF00">ejs-2&gt;</font> s = new Shape(5, 10)
<font color="#FFFF00"><strong>[object Shape]</strong></font>
<font color="#FFFF00">ejs-2&gt;</font> s2 = new Shape(5, 5)
<font color="#FFFF00"><strong>[object Shape]</strong></font>
</pre>We can also create new derived shape classes using the Shape class as a base.
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> class Circle extends Shape {
<font color="#FFFF00">ejs-2&gt;</font>   var radius
<font color="#FFFF00">ejs-2&gt;</font>   function Circle(radius) {
<font color="#FFFF00">ejs-2&gt;</font>     super(radius, radius)
<font color="#FFFF00">ejs-2&gt;</font>   }
<font color="#FFFF00">ejs-2&gt;</font> }
<font color="#FFFF00">ejs-0&gt;</font> circle = new Circle(25)
<font color="#FFFF00"><strong>[object Circle]</strong></font>
</pre>
            <p>Once we've created an instance of an object we can access the properties of that object using dot
            notation.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> s = new Shape(100, 200)
<font color="#FFFF00">ejs-0&gt;</font> print(s.height)
<font color="#FFFF00"><strong>100</strong></font>
</pre>
            <h2><a name="objects" id="objects"></a>Objects</h2>
            <p>You can also create objects without having to create a class. Object literals provide a convenient way
            to create and initialize an object in one step.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> s = { height: 500, width: 400 }
<font color="#FFFF00">ejs-0&gt;</font> print(s.height)
<font color="#FFFF00"><strong>500</strong></font>
<font color="#FFFF00">ejs-0&gt;</font> serialize(s)<font color="#FFFF00"><strong>
{
  height: 500,
  width: 400,
}</strong></font>
</pre>
            <p>In this example, we also use the <strong>serialize</strong> function to convert the object "s" into a
            string exposing all the properties and their values. Object literals can also be nested.</p>
            <h2><a name="hashes" id="hashes"></a>Hashes</h2>
            <p>In Ejscript, objects are frequently used as hashes to store key / value pairs.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> hash = new Object
<font color="#FFFF00">ejs-0&gt;</font> hash["red"] = "Favorite color"
<font color="#FFFF00">ejs-0&gt;</font> hash["blue"] = "Next favorite"
<font color="#FFFF00">ejs-0&gt;</font> hash["green"] = "Least likely"
<font color="#FFFF00">ejs-0&gt;</font> print(hash["red"])
<strong><font color="#FFFF00">Favorite Color</font></strong>
</pre>
            <p>To access hash elements, use "[]" to lookup by a key string.</p>
            <p>Classes and Interaces are also objects in their own right. You can store them and assign them. This is
            very useful in creating type factories. Continuing the previous example, we can store the Shape and Circle
            class types into a factory hash.</p>
            <pre>
<font color="#FFFF00">
ejs-2&gt;</font> factory = {}
<font color="#FFFF00">ejs-0&gt;</font> factory["shape"] = Shape
<font color="#FFFF00">ejs-0&gt;</font> factory["circle"] = Circle
<font color="#FFFF00">ejs-0&gt;</font> kind = "shape"
<font color="#FFFF00">ejs-0&gt;</font> thing = new factory[kind]
</pre>
            <p>In this example we used "factory = {}". This is a fequently used shorthand for saying factory = new
            Object.</p>
            <h2><a name="arrays" id="arrays"></a>Arrays</h2>
            <p>Arrays are created using the new keyword. There are several forms of constructor usage for Arrays, the
            most common is to specify the size of the array.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> a = new Array(10)
<font color="#FFFF00">ejs-0&gt;</font> print(a.length)
<font color="#FFFF00"><strong>10</strong></font>
</pre>You can also create an Array using an Array literal syntax by enclosing the desired array elements inside square
brackets.
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> b = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
<font color="#FFFF00">ejs-0&gt;</font> print(b.length)
<font color="#FFFF00"><strong>10</strong></font>
<font color="#FFFF00">ejs-0&gt;</font> print(b)
0,1,2,3,4,5,6,7,8,9
</pre>
            <p>You can print the length of the array using the <b>length</b> getter function. You can also convert the
            array to a string and print it out.</p>
            <h2><a name="types" id="types"></a>Type Annotations</h2>
            <p>So far we've just declared variables and not specified their type. At run time, the Ejscript virtual
            machine manages the type of the variables. Sometimes known as Duck-typing, this is certainly easier than
            having to pre-declare the types of all variables. But there are cases where it is highly desirable to
            specify the type a variable can hold. Instead of typing "String name;" as you would in Java, in Ejscript
            you use a postfix type annotation. For example:</p>
            <pre>
var name: String
</pre>
            <p>This defines a new variable called <b>name</b> that will always hold strings. In Ejscript type
            annotations come after the variable and are optional. You can choose which variables, functions and
            parameters you wish to type.</p>
            <p>Function arguments and function return values can also be typed:</p>
            <pre>
function add(x: Number, y: Number): Number {
  return x + y
}
</pre>
            <p>So when is it desirable to annotate your variable or function declarations with types?</p>
            <ul>
                <li>When you are creating a class library and you want to specify exactly what types are acceptable as
                arguments to functions.</li>
                <li>When you want your code to run as fast as possible. By adding type annotations, the compiler can
                perform optimizations to bind property accesses into actual storage references.</li>
                <li>When you want your code to be robust and you want the compiler and Virtual Machine to convert types
                or catch type mismatches for you as early as possible.</li>
            </ul>
            <p>Another general rule is that when you are creating code that will be used by others and they need to
            have it clearly documented, use type annotations.</p>
            <h2><a name="statements" id="statements"></a>Statements</h2>
            <p>Ejscript statements are C-like and include: break, case, cast, class, continue, catch, class, default,
            delete, do, finally, for, for/in, for each, function, if/else, include, interface, let, new, return, super,
            switch, try, use and var.</p>
            <p>Let's use a few (we'll omit the shell prompts in this example):</p>
            <pre>
/*<br /> *  Can use either C or C++ style comments<br /> */
class MyDemo {
  function test(low, high) {
    let i, j;                   // Declare locals with let
    let objects = new Array(10) // Create an array of ten elements
    
    for (i in 10) {             // Classic for loop
      objects[i] = new Object   // Store a new object
    }
    for each (o in objects) {   // Iterate over all the objects
      try {
        // Can do something here to each object
      }
      catch (error) {
        print("Got an error: " + error)
      }
    }
    return low &lt; high ? low : high
  }
}
var demo = new MyDemo
demo.test(0, 10)
                    
</pre>
            <p>There were a couple of unusual constructs in that snippet to discuss.</p>
            <h3>Let Declarations and Block Scope</h3>
            <p>Variables may be declared with either <strong>var</strong> or <strong>let</strong>. Let will always
            define variables at the block level in which they are declared. ie. always block scoped. In ECMAScript, var
            declarations always hoist to the nearest enclosing function, class or global space.</p>
            <h3>For ... in</h3>
            <p>The "for (i in 10)" statement seems a little unusual. Isn't 10 a primitive type? The answer is yes, but
            Ejscript treats all numbers as objects. You can invoke methods on numbers and you can iterate through their
            values. This for/in statement will iterate through all the numbers from 0 up to but not including 10. ie.
            0-9. Much easier than typing "for (i = 0; i &lt; 10; i++)" eh?</p>
            <h2><a name="iteration" id="iteration"></a>Iteration</h2>
            <p>Ejscript has powerful iteration capabilities and most types have built-in iterators for common tasks.
            Here are a few examples:</p>
            <p>To loop through the characters in a string:</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> for each (s in "Hello")
<font color="#FFFF00">ejs-0&gt;</font>   print(s)
<strong><font color="#FFFF00">
H
e
l
l
o</font></strong>
</pre>
            <p>To count to 100</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> for each (i in 100)
<font color="#FFFF00"><strong>0
1
...
99</strong></font>
</pre>
            <h2><a name="scope" id="scope"></a>Scope</h2>
            <p>Ejscript is a lexically scoped language. This means that variables are visible by default in the block
            in which they are declared and in inner blocks.</p>
            <p>In this example, the variable factor is visible inside the function increment but the variable temp is
            local to the function and not visible outside.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt; </font>var factor = 10
<font color="#FFFF00">ejs-0&gt;</font> function increment(x) {
<font color="#FFFF00">ejs-0&gt; </font>  var temp = x * x
<font color="#FFFF00">ejs-0&gt; </font>  return temp + factor       // Variable factor is visible
<font color="#FFFF00">ejs-0&gt; </font>}
<font color="#FFFF00">ejs-0&gt; </font>// Variable temp is not visible here
</pre>
            <p>But what if we declare another variable called "factor" inside the function. Consider this:</p>
            <pre>
<font color="#FFFF00">ejs-0&gt; </font>var factor = 10
<font color="#FFFF00">ejs-0&gt;</font> function increment(x) {
<font color="#FFFF00">ejs-0&gt;</font>   let factor = 1
<font color="#FFFF00">ejs-0&gt; </font>  var temp = x * x
<font color="#FFFF00">ejs-0&gt; </font>  return temp + factor       // factor == 1
<font color="#FFFF00">ejs-0&gt; </font>}
<font color="#FFFF00">ejs-0&gt; </font>// Variable temp is not visible here
</pre>
            <p>This second declaration of factor inside the function <em>shadows</em> the first declaration only while
            inside the function. Once outside, the first declaration is visible again.</p>
            <p>These scoping rules apply to functions, classes, and indeed any blocks of code.</p>
            <h2><a name="namespaces" id="namespaces"></a>Namespaces</h2>
            <p>To help control the visibility of names, they can be given namespace qualifiers. Think of this as a
            two-dimensional variable name space. Instead of just the variable name, the fully qualified variable name
            consists of the name plus the namespace name.</p>
            <p>Namespaces are useful to prevent names from different contexts clashing. In other languages such as
            Java, packages and imports are used to group and seggregate declarations. In Ejscript, namespaces are also
            used for this purpose.</p>
            <p>With namespaces you can now have two variables named x in the same block.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> var x = "first"
<font color="#FFFF00">ejs-0&gt;</font> var "com.embedthis"::x = "second"
<font color="#FFFF00">ejs-0&gt;</font> print(x)
<font color="#FFFF00"><strong>first</strong></font>
<font color="#FFFF00">ejs-0&gt;</font> print("com.embedthis"::x)
<font color="#FFFF00"><strong>second</strong></font>
</pre>
            <p>The second variable declaration is qualified by "com.embedthis" and is a separate declaration to the
            first. The namespace qualifier can either be a literal string or can be a variable of the type Namespace.
            The qualifier is separated from the name by the "::" delimiter.</p>
            <p>While that looks okay, I hear you ask "surely there is a more convenient way to use namespaces?". Yes,
            there is. Namespaces are used most frequently in modules.</p>
            <h2>Modules</h2>
            <p>The most common need for Namespaces is to package related code so that it will not have name clashes
            with other code declarations. Java uses packages and import directives for this purpose, Ejscript uses
            modules &mdash; based on Namespaces. A module directive groups variables, functions and classes into a
            single namespace. A module can be imported via the "require" directive.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> module Test {
<font color="#FFFF00">ejs-0&gt;</font>     var x = "hello"
<font color="#FFFF00">ejs-0&gt;</font> }
<font color="#FFFF00">ejs-0&gt;</font> require Test
<font color="#FFFF00">ejs-0&gt;</font> print(x)
<strong><font color="#FFFF00">hello</font></strong>
</pre>
            <p>This code will create a module Test with a variable X that is actually named: "Test::x". i.e it is
            prefixed with the namespace "Test". A typical paradigm is to create modules patterned after a domain name
            such as "com.embedthis.Test".</p>
            <p>If using the <strong>ec</strong> stand-alone compiler, the Test module will be compiled into a separate
            byte code file called "test.mod".</p>
            <h2><a name="closures" id="closures"></a>Closures</h2>
            <p>To complete the discussion about Scope, Ejscript has an important and very powerful construct called a
            closure. This is where a function can be captured in the context in which it is defined. The capture
            includes its full lexical scope and if the function is a method in a class, then the <strong>this</strong>
            instance object will also be captured.</p>
            <p>Closures and method capture are most useful when you wish to pass a function with its execution context
            as a parameter to another function.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> class Rectangle {
<font color="#FFFF00">ejs-0&gt;</font>   var color = "red"
<font color="#FFFF00">ejs-0&gt;</font>   function render() {
<font color="#FFFF00">ejs-0&gt;</font>     print("In render: color " + color)
<font color="#FFFF00">ejs-0&gt;</font>   }
<font color="#FFFF00">ejs-0&gt;</font> }
<font color="#FFFF00">ejs-0&gt;</font> box = new Rectangle
<font color="#FFFF00">ejs-0&gt;</font> new Timer(5000, box.render)
</pre>
            <p>This example creates a class called Rectangle and creates an instance called box. It then creates a
            timer which will invoke the render method of the rectangle in 5 seconds. When <strong>box.render</strong>
            is passed as a parameter, Ejscript captures the value of the box (this) reference and remembers it. When
            the timer later invokes the render method, it invokes it with the right instance of Rectangle.</p>
            <h2><a name="exceptions" id="exceptions"></a>Exceptions</h2>
            <p>Frequently things go wrong in a program. Exceptions allow you to structure your error handling code
            without obscuring the main logic flow.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> try {
<font color="#FFFF00">ejs-0&gt;</font>   missing()
<font color="#FFFF00">ejs-0&gt;</font> }
<font color="#FFFF00">ejs-0&gt;</font> catch (error) {
<font color="#FFFF00">ejs-0&gt;</font>   print("Caught the error")
<font color="#FFFF00">ejs-0&gt;</font> }
<font color="#FFFF00"><strong>Caught the error</strong></font>
</pre>
            <p>Ejscript exceptions allow us to "try" something and if an error occurred, then we catch the error in a
            dedicated block of code.</p>
            <h2><a name="library" id="library"></a>Script Library</h2>
            <p>Ejscript comes with an extensive class <a href="../../../api/ejscript/index.html">library</a>. It
            includes class for Events, Timers, File I/O, HTTP, Sockets, XML and much more. To give you a feel for the
            library, here is how to read lines from a file.</p>
            <pre>
<font color="#FFFF00">ejs-0&gt;</font> for each (line in Path("filename").readLines()) {
<font color="#FFFF00">ejs-0&gt;</font>   print(line)
<font color="#FFFF00">ejs-0&gt;</font> }
</pre>
        </div>
    </div>
<!-- BeginDsi "dsi/bottom.html" -->
	<div class="bottom">
		<p class="footnote"> 
            <a href="../../../product/copyright.html" >&copy; Embedthis Software LLC, 2003-2010. 
            All rights reserved. Embedthis, Ejscript and Appweb are trademarks of Embedthis Software LLC.</a>
		</p>
	</div>
<!-- EndDsi -->
</body>
</html>
