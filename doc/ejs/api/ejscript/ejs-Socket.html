<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
   <title>Class Socket</title>

   <link rel="stylesheet" type="text/css" href="doc.css" />
</head>

<body>
<div class='body'>

<div class="content">

<a name='top'></a>
<h1 class='className'>Socket</h1>
<div class='classBlock'>
<table class='classHead' summary='Socket'>
   <tr><td><strong>Module</strong></td><td>ejs</td></tr>
   <tr><td><strong>Definition</strong></td><td> class Socket</td></tr>
   <tr><td><strong>Inheritance</strong></td><td>Socket <img src='images/inherit.gif' alt='inherit'/> <a href='ejs-Object.html'>Object</a>       </td></tr>
</table>

<p class='classBrief'>Create a socket object.</p>

<p class='classDescription'></p>

</div>


<hr />
<a name='Properties'></a>
<h2 class='classSection'>Properties</h2>
<table class='itemTable' summary='properties'>
   <tr><th>Qualifiers</th><th>Property</th><th>Type</th><th width='95%'>Description</th></tr>
<a name='address'></a>
   <tr><td nowrap align='left'>public const get </td><td>address</td><td><a href='ejs-String.html'>String</a></td><td>Local IP address bound to this socket. Set to the address in dot notation or empty string if it is not bound.</td></tr>
<a name='port'></a>
   <tr><td nowrap align='left'>public const get </td><td>port</td><td><a href='ejs-Number.html'>Number</a></td><td>The port bound to this socket. Set to the integer port number or zero if not bound.</td></tr>
<a name='remoteAddress'></a>
   <tr><td nowrap align='left'>public const get </td><td>remoteAddress</td><td><a href='ejs-String.html'>String</a></td><td>The remote address bound to this socket. Set to the remote address in dot notation or empty string if it 
is not bound.</td></tr>
</table>

<p class='inheritedLink'><a href='ejs-Object.html#Properties'><i>Inherited Properties</i></a></p>

<hr />
<a name='Methods'></a>
<h2 class='classSection'>Socket Methods</h2>
<table class='apiIndex' summary='methods'>
   <tr><th>Qualifiers</th><th width='95%'>Method</th></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#accept'><b>accept</b></a>(): <a href='ejs-Socket.html'>Socket</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Receive a client socket in response to a "connect" event.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#close'><b>close</b></a>(): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Close the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#connect'><b>connect</b></a>(address: <a href='ejs-Object.html'>Object</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Establish a connection to a client from this socket to the supplied address.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#flush'><b>flush</b></a>(dir: <a href='ejs-Number.html'>Number</a> = expression): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Flush the stream and underlying streams.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#listen'><b>listen</b></a>(address): <a href='ejs-Socket.html'>Socket</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Listen on a socket for client connections.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#off'><b>off</b></a>(name: <a href='ejs-Object.html'>Object</a>, observer: <a href='ejs-Function.html'>Function</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Remove an observer from the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#on'><b>on</b></a>(name, observer: <a href='ejs-Function.html'>Function</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Add an observer to the stream for the named events.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#read'><b>read</b></a>(buffer: <a href='ejs-ByteArray.html'>ByteArray</a>, offset: <a href='ejs-Number.html'>Number</a> = 0 , count: <a href='ejs-Number.html'>Number</a> = -1): <a href='ejs-Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a data from the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#write'><b>write</b></a>(data: <a href='ejs-Array.html'>Array</a>): <a href='ejs-Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write data to the stream.</td></tr>
</table>

<p class='inheritedLink'><a href='ejs-Object.html#Methods'><i>Inherited Methods</i></a></p>

<hr />
<h2>Method Detail</h2>
<a name='accept'></a>
<div class='api'>
<div class='apiSig'>const   public  accept(): <a href='ejs-Socket.html'>Socket</a>
</div>
<div class='apiDetail'>
<p>Receive a client socket in response to a "connect" event.</p>
<dl><dt>Description</dt><dd>The accept call must be called after invoking
<a href='#listen'>listen</a> and receiving a client connection.</dd></dl>
<dl><dt>Returns</dt>
<dd>A socket connected to the client endpoint.</dd></dl>
</div>
</div>
<hr />
<a name='close'></a>
<div class='api'>
<div class='apiSig'>const   public  close(): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Close the stream.</p>
<dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>close</td><td>A close event is issued before closing the stream.</td></tr>
</table></dd>
</dl></div>
</div>
<hr />
<a name='connect'></a>
<div class='api'>
<div class='apiSig'>const   public  connect(address: <a href='ejs-Object.html'>Object</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Establish a connection to a client from this socket to the supplied address.</p>
<dl><dt>Description</dt><dd>After a successful call to 
connect() the socket may be used for sending and receiving.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>address: <a href='ejs-Object.html'>Object</a> </td><td>The endpoint address on which to listen. The address can be either a port number, an IP address string or a composite "IP:PORT" string. If only a port number is provided, the socket will listen on all interfaces.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>Issues</td><td>A "connect" event when the connection is complete.</td></tr>
</table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if the connection fails. Reasons may include the socket is already bound or the host is unknown. 
</dd>
</dl></div>
</div>
<hr />
<a name='flush'></a>
<div class='api'>
<div class='apiSig'>const   public  flush(dir: <a href='ejs-Number.html'>Number</a> = expression): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Flush the stream and underlying streams.</p>
<dl><dt>Description</dt><dd>A supplied flush <a href='#direction'>direction</a> argument modifies the effect of this call.
If direction is set to Stream.READ, then all read data is discarded. If direction is set to Stream.WRITE, 
any buffered data is written. Stream.BOTH will cause both directions to be flushed.  If the stream is in 
sync mode, this call will block until all data is written. If the stream is in async mode, it will attempt 
to write all data but will return immediately</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>dir: <a href='ejs-Number.html'>Number</a> </td><td> [default: expression]</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='listen'></a>
<div class='api'>
<div class='apiSig'>const   public  listen(address): <a href='ejs-Socket.html'>Socket</a>
</div>
<div class='apiDetail'>
<p>Listen on a socket for client connections.</p>
<dl><dt>Description</dt><dd>This will put the socket into a server role for communcations.
If the socket is in sync mode, the listen call will block until a client connection is received and
the call will return the client socket. 
If a the listening socket is in async mode, the listen call will return immediately and 
client connections will be notified via "accept" events. 
In this case, when a client connection is received, the <a href='#accept'>accept</a> function must be called to 
receive the client socket object for the connection.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>address </td><td>The endpoint address on which to listen. The address can be either a port number, an IP address string or a composite "IP:PORT" string. If only a port number is provided, the socket will listen on all interfaces.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>Issues</td><td>A "accept" event when there is a new connection available. In response, the <a href='#accept'>accept</a> method should be called.</td></tr>
</table></dd>
</dl><dl><dt>Returns</dt>
<dd>A client socket if in sync mode. No return value if in async mode.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='ejs-ArgError.html'>ArgError</a>: if the specified listen address is not valid, and IOError for network errors. 
</dd>
</dl></div>
</div>
<hr />
<a name='off'></a>
<div class='api'>
<div class='apiSig'>const   public  off(name: <a href='ejs-Object.html'>Object</a>, observer: <a href='ejs-Function.html'>Function</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Remove an observer from the stream.</p>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>name: <a href='ejs-Object.html'>Object</a> </td><td>Event name previously used with observe. The name may be an array of events.</td></tr><tr class='param'><td class='param'>observer: <a href='ejs-Function.html'>Function</a> </td><td>Observer function previously used with observe.</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='on'></a>
<div class='api'>
<div class='apiSig'>const   public  on(name, observer: <a href='ejs-Function.html'>Function</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Add an observer to the stream for the named events.</p>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>name </td><td>Name of the event to listen for. The name may be an array of events.</td></tr><tr class='param'><td class='param'>observer: <a href='ejs-Function.html'>Function</a> </td><td>Callback observer function. The function is called with the following signature: function observer(event: String, ...args): Void.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when the stream becomes readable.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes writable.</td></tr>
<td class='param'>close</td><td>Issued when stream is being closed.</td></tr>
<td class='param'>readable</td><td>Issued when the response headers have been fully received and some body content is available.</td></tr>
<td class='param'>writable</td><td>Issued when the connection is writable to accept body data (PUT, POST).</td></tr>
</table></dd>
</dl></div>
</div>
<hr />
<a name='read'></a>
<div class='api'>
<div class='apiSig'>const   public  read(buffer: <a href='ejs-ByteArray.html'>ByteArray</a>, offset: <a href='ejs-Number.html'>Number</a> = 0 , count: <a href='ejs-Number.html'>Number</a> = -1): <a href='ejs-Number.html'>Number</a>
</div>
<div class='apiDetail'>
<p>Read a data from the stream.</p>
<dl><dt>Description</dt><dd>If data is available, the call will return immediately. 
If no data is available and the stream is in sync mode, the call will block until data is available.
If no data is available and the stream is in async mode, the call will not block and will return immediately.
In this case a "readable" event will be issued when data is available for reading.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>buffer: <a href='ejs-ByteArray.html'>ByteArray</a> </td><td>Destination byte array for read data.</td></tr><tr class='param'><td class='param'>offset: <a href='ejs-Number.html'>Number</a> </td><td>Offset in the byte array to place the data. If the offset is -1, then data is appended to the buffer write <a href='#position'>position</a> which is then updated [default: 0 ]</td></tr><tr class='param'><td class='param'>count: <a href='ejs-Number.html'>Number</a> </td><td>Read up to this number of bytes. If -1, read as much as the buffer will hold up. If the  stream is of fixed and known length (such as a file) and the buffer is of sufficient size or is growable,  read the entire stream. [default: -1]</td></tr><tr class='param'><td class='param'>offset: <a href='ejs-Number.html'>Number</a> </td><td> [default: 0 ]</td></tr><tr class='param'><td class='param'>count: <a href='ejs-Number.html'>Number</a> </td><td> [default: -1]</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when there is new read data available.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes empty.</td></tr>
</table></dd>
</dl><dl><dt>Returns</dt>
<dd>A count of the bytes actually read. Returns null on eof.</dd></dl>
</div>
</div>
<hr />
<a name='write'></a>
<div class='api'>
<div class='apiSig'>const   public  write(data: <a href='ejs-Array.html'>Array</a>): <a href='ejs-Number.html'>Number</a>
</div>
<div class='apiDetail'>
<p>Write data to the stream.</p>
<dl><dt>Description</dt><dd>If the stream can accept all the write data, the call returns immediately with the number of bytes written. 
If writing more data than the stream can absorb in sync mode, the call will block until the data is written.
If writing more data than the stream can absorb in async mode, the call will not block and will buffer the
data and return immediately. Some streams will require a flush() call to actually send the data.
A "writable" event will be issued when the stream can again absorb more data.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>data: <a href='ejs-Array.html'>Array</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes empty and it is ready to be written to.</td></tr>
</table></dd>
</dl><dl><dt>Returns</dt>
<dd>A count of the bytes actually written.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if there is an I/O error. 
</dd>
</dl></div>
</div>
<hr />
<div class="terms">
   <p class="terms">
       <a href="http://www.embedthis.com/">       Embedthis Software LLC, 2003-2010. All rights reserved. Embedthis is a trademark of Embedthis Software LLC.</a>
   </p>
</div></div>
</div>
</body>
</html>
