<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
   <title>Class HttpServer</title>

   <link rel="stylesheet" type="text/css" href="doc.css" />
</head>

<body>
<div class='body'>

<div class="content">

<a name='top'></a>
<h1 class='className'>HttpServer</h1>
<div class='classBlock'>
<table class='classHead' summary='HttpServer'>
   <tr><td><strong>Module</strong></td><td>ejs.web</td></tr>
   <tr><td><strong>Definition</strong></td><td>dynamic  class HttpServer</td></tr>
   <tr><td><strong>Inheritance</strong></td><td>HttpServer <img src='images/inherit.gif' alt='inherit'/> <a href='ejs-Object.html'>Object</a><tr><td><strong>Specified</strong></td><td>ejscript-2.0</td></tr>
<tr><td><strong>Stability</strong></td><td>Prototype.</td></tr>
<tr><td><strong>Example</strong></td><td><pre>
            let server: HttpServer = new HttpServer(".", "web")
            let router = Router(Router.Restful)
            server.on("readable", function (event: String, request: Request) {
                request.status = 200
                request.setHeaders({"Content-Type": "text/plain"})
                request.on("readable", function (event, request) {
                    let data = new ByteArray
                    if (request.read(data) == null) {
                        print("EOF")
                    }
                })
                request.on("writable", function (event) {
                    request.write("Hello World")
                    request.finalize()
                })
            }
            server.listen("127.0.0.1:7777")
         
</pre></td></tr>
       </td></tr>
</table>

<p class='classBrief'>Create a HttpServer object.</p>

<p class='classDescription'>The server is created in async mode by default.</p>

</div>


<hr />
<a name='Properties'></a>
<h2 class='classSection'>Properties</h2>
<table class='itemTable' summary='properties'>
   <tr><th>Qualifiers</th><th>Property</th><th>Type</th><th width='95%'>Description</th></tr>
<a name='indicies'></a>
   <tr><td nowrap align='center'>public static </td><td>indicies</td><td>&nbsp;</td><td>Index files list. Index files are used by various handlers when requests to directories are made. The 
indicies are tried in turn for the first valid index file.</td></tr>
<a name='documentRoot'></a>
   <tr><td nowrap align='center'>public </td><td>documentRoot</td><td><a href='ejs-Path.html'>Path</a></td><td>Default local directory for web documents to serve. This is used as the default Request.dir value.</td></tr>
<a name='serverRoot'></a>
   <tr><td nowrap align='center'>public </td><td>serverRoot</td><td><a href='ejs-Path.html'>Path</a></td><td>Default root directory for the server. The app does not change its current directory to this path.</td></tr>
<a name='sessions'></a>
   <tr><td nowrap align='center'>public </td><td>sessions</td><td><a href='ejs-Object.html'>Object</a></td><td>Hash of session objects. This is created on demand as requests require session state storage.</td></tr>
<a name='address'></a>
   <tr><td nowrap align='left'>public const get </td><td>address</td><td><a href='ejs-String.html'>String</a></td><td>Get the local IP address bound to this socket. </td></tr>
<a name='isSecure'></a>
   <tr><td nowrap align='left'>public const get </td><td>isSecure</td><td><a href='ejs-Boolean.html'>Boolean</a></td><td>Flag indicating if the server is using secure communications. This means that TLS/SSL is the underlying
protocol scheme.</td></tr>
<a name='limits'></a>
   <tr><td nowrap align='left'>public const get </td><td>limits</td><td><a href='ejs-Object.html'>Object</a></td><td>Resource limits for the server and for initial resource limits for requests. </td></tr>
<a name='port'></a>
   <tr><td nowrap align='left'>public const get </td><td>port</td><td><a href='ejs-Number.html'>Number</a></td><td>Get the port bound to this Http endpoint. </td></tr>
<a name='software'></a>
   <tr><td nowrap align='left'>public const get </td><td>software</td><td><a href='ejs-String.html'>String</a></td><td>Software details for the web server. </td></tr>
</table>

<p class='inheritedLink'><a href='ejs-Object.html#Properties'><i>Inherited Properties</i></a></p>

<hr />
<a name='Methods'></a>
<h2 class='classSection'>HttpServer Methods</h2>
<table class='apiIndex' summary='methods'>
   <tr><th>Qualifiers</th><th width='95%'>Method</th></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#accept'><b>accept</b></a>(): <a href='ejs.web-Request.html'>Request</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Accept a new incoming for sync servers.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#close'><b>close</b></a>(): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Close the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#listen'><b>listen</b></a>(endpoint: <a href='ejs-String.html'>String</a> = null): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Listen for client connections.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#off'><b>off</b></a>(name: <a href='ejs-Object.html'>Object</a>, observer: <a href='ejs-Function.html'>Function</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Remove an observer from the server.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#on'><b>on</b></a>(name, observer: <a href='ejs-Function.html'>Function</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Add an observer for server events.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#secure'><b>secure</b></a>(keyFile: <a href='ejs-Path.html'>Path</a>, certFile: <a href='ejs-Path.html'>Path</a>, protocols: <a href='ejs-Array.html'>Array</a> = null , ciphers: <a href='ejs-Array.html'>Array</a> = null): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Define the Secure Sockets Layer (SSL) protocol credentials.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#setLimits'><b>setLimits</b></a>(limits: <a href='ejs-Object.html'>Object</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Update the server resource limits.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#setPipeline'><b>setPipeline</b></a>(incoming: <a href='ejs-Array.html'>Array</a>, outgoing: <a href='ejs-Array.html'>Array</a>, connector: <a href='ejs-String.html'>String</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Define the stages of the Http processing pipeline.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#trace'><b>trace</b></a>(options: <a href='ejs-Object.html'>Object</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Configure request tracing for the server.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#verifyClients'><b>verifyClients</b></a>(caCertPath: <a href='ejs-Path.html'>Path</a>, caCertFile: <a href='ejs-Path.html'>Path</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Verify client certificates.</td></tr>
</table>

<p class='inheritedLink'><a href='ejs-Object.html#Methods'><i>Inherited Methods</i></a></p>

<hr />
<h2>Method Detail</h2>
<a name='accept'></a>
<div class='api'>
<div class='apiSig'>const   public  accept(): <a href='ejs.web-Request.html'>Request</a>
</div>
<div class='apiDetail'>
<p>Accept a new incoming for sync servers.</p>
<dl><dt>Description</dt><dd>This call creates a request object in response to an 
incoming client connection on the current HttpServer object.  In async mode, the accept() call is not needed
as the HttpServer automatically creates the Request object and passes it on "readable" events.</dd></dl>
<dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>Issues</td><td>A "accept" event when there is a new connection available.</td></tr>
</table></dd>
</dl><dl><dt>Returns</dt>
<dd>A Request object if in sync mode. No return value if in async mode.</dd></dl>
<dl><dt>Example</dt>
<dd><pre>server = new HttpServer
server.listen("8080")
while (request = server.accept()) {
    Web.serve(request)
}
</pre></dd></dl>
</div>
</div>
<hr />
<a name='close'></a>
<div class='api'>
<div class='apiSig'>const   public  close(): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Close the stream.</p>
<dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>close</td><td>A close event is issued before closing the stream.</td></tr>
</table></dd>
</dl></div>
</div>
<hr />
<a name='listen'></a>
<div class='api'>
<div class='apiSig'>const   public  listen(endpoint: <a href='ejs-String.html'>String</a> = null): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Listen for client connections.</p>
<dl><dt>Description</dt><dd>This creates a HTTP server listening on a single socket endpoint. It can
also be used to attach to an existing listening connection if embedded in a web server. <br/><br/>When used inside a web server, the web server should define the listening endpoints and ensure the 
EjsScript startup script is executed. Then, when listen is called, the HttpServer object will be bound to
the web server's listening connection. In this case, the endpoint argument is not required and is ignored.<br/><br/>HttpServer supports both sync and async modes of operation.  In sync mode, after listen call is made, 
<a href='#accept'>accept</a> must be called to wait for and receive client connections. The <a href='#accept'>accept</a> call will create the 
Request object.  In async mode, Request objects will be created automatically and passed to registered 
observers via "readable" events.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>endpoint: <a href='ejs-String.html'>String</a> </td><td>The endpoint address on which to listen. An endoint may be a port number or a composite  "IP:PORT" string. If only a port number is provided, the socket will listen on all interfaces on that port.  If null is provided for an endpoint value, an existing web server listening connection will be used. In this case, the web server will typically be the virtual host that specifies the EjsStartup script. See the hosting web server documentation for specifics. [default: null]</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>Issues</td><td>A "accept" event when there is a new connection available.</td></tr>
</table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='ejs-ArgError.html'>ArgError</a>: if the specified endpoint address is not valid or available for binding. 
</dd>
</dl><dl><dt>Example</dt>
<dd><pre>server = new Http(".", "./web")
server.on("readable", function (event, request) {
    //  NOTE: this is set to the request
    Web.serve(request)
})
server.listen("80")
</pre></dd></dl>
</div>
</div>
<hr />
<a name='off'></a>
<div class='api'>
<div class='apiSig'>const   public  off(name: <a href='ejs-Object.html'>Object</a>, observer: <a href='ejs-Function.html'>Function</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Remove an observer from the server.</p>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>name: <a href='ejs-Object.html'>Object</a> </td><td>Event name previously used with observe. The name may be an array of events.</td></tr><tr class='param'><td class='param'>observer: <a href='ejs-Function.html'>Function</a> </td><td>Observer function previously used with observe.</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='on'></a>
<div class='api'>
<div class='apiSig'>const   public  on(name, observer: <a href='ejs-Function.html'>Function</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Add an observer for server events.</p>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>name </td><td>Name of the event to listen for. The name may be an array of events.</td></tr><tr class='param'><td class='param'>observer: <a href='ejs-Function.html'>Function</a> </td><td>Callback listening function. The function is called with the following signature: function on(event: String, ...args): Void.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when there is a new request available. This readable event will explicitlyl set the value of "this" to the request regardless of whether the function has a bound "this" value.</td></tr>
<td class='param'>close</td><td>Issued when server is being closed.</td></tr>
<td class='param'>createSession</td><td>Issued when a new session store object is created for a client. The request object is passed.</td></tr>
<td class='param'>destroySession</td><td>Issued when a session is destroyed. The request object is passed.</td></tr>
</table></dd>
</dl></div>
</div>
<hr />
<a name='secure'></a>
<div class='api'>
<div class='apiSig'>const   public  secure(keyFile: <a href='ejs-Path.html'>Path</a>, certFile: <a href='ejs-Path.html'>Path</a>, protocols: <a href='ejs-Array.html'>Array</a> = null , ciphers: <a href='ejs-Array.html'>Array</a> = null): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Define the Secure Sockets Layer (SSL) protocol credentials.</p>
<dl><dt>Description</dt><dd>This must be done before calling <a href='#listen'>listen</a>. </dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>keyFile: <a href='ejs-Path.html'>Path</a> </td><td>Path of the file containing the server's private key. This file contains the PEM encoded private key file for the server. Set to null if the private key is combined with  the certificate file. If the private key is encrypted, you will be prompted at the console to enter the  pass-phrase to decript the private key on system reboot. There is a delima here. If you use a crypted  private key, the server will pause until you enter the pass-phrase which makes headless operation impossible.  If you do not encrypt the private key, your private key is more vulnerable should the server be compromised.  Which option you choose depends on whether headless operation is essential or not.</td></tr><tr class='param'><td class='param'>certFile: <a href='ejs-Path.html'>Path</a> </td><td>Path of the file containing the SSL certificate The certificate file contains the PEM encoded X.509 certificate for the server. The file may also contain  the private key in which case you should set the key parameter to null. The path may be an absolute path or it may be relative to the ServerRoot.</td></tr><tr class='param'><td class='param'>protocols: <a href='ejs-Array.html'>Array</a> </td><td>Optional arary of SSL protocols to support. Select from: SSLv2, SSLv3, TLSv1, ALL.  Each protocol can be prefixed by "+" or "-" to add or subtract from the prior set. For example: ["ALL", "-SSLv2"], or ["SSLv3", "TLSv1"] or "[ALL]". [default: null ]</td></tr><tr class='param'><td class='param'>ciphers: <a href='ejs-Array.html'>Array</a> </td><td>Optional array of ciphers to use when negotiating the SSL connection. Not yet supported. [default: null]</td></tr></table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='ejs-ArgError.html'>ArgError</a>: for invalid arguments  
</dd>
</dl></div>
</div>
<hr />
<a name='setLimits'></a>
<div class='api'>
<div class='apiSig'>const   public  setLimits(limits: <a href='ejs-Object.html'>Object</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Update the server resource limits.</p>
<dl><dt>Description</dt><dd>The supplied limit fields are updated.
See the <a href='#limits'>limits</a> property for limit field details.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>limits: <a href='ejs-Object.html'>Object</a> </td><td>Object hash of limit fields and values.</td></tr></table></dd>
</dl><dl><dt>See Also</dt>
<dd>
<a href='limits.html'>limits</a>
</dd></dl>
</div>
</div>
<hr />
<a name='setPipeline'></a>
<div class='api'>
<div class='apiSig'>const   public  setPipeline(incoming: <a href='ejs-Array.html'>Array</a>, outgoing: <a href='ejs-Array.html'>Array</a>, connector: <a href='ejs-String.html'>String</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Define the stages of the Http processing pipeline.</p>
<dl><dt>Description</dt><dd>Data flows through the processing pipeline and is
filtered or transmuted by filter stages. A communications connector is responsible for transmitting to 
the network.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>incoming: <a href='ejs-Array.html'>Array</a> </td><td>Array of stages for the incoming pipeline: default: ["chunk", "range", "upload"].</td></tr><tr class='param'><td class='param'>outgoing: <a href='ejs-Array.html'>Array</a> </td><td>Array of stages for the outgoing pipeline: default: ["auth", "range", "chunk"].</td></tr><tr class='param'><td class='param'>connector: <a href='ejs-String.html'>String</a> </td><td>Network connector to use for I/O. Defaults to the network connector "net". Other values: "send". The "net" connector transparently upgrades to the "send" connector if transmitting static data and  not using SSL, ranged or chunked transfers.</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='trace'></a>
<div class='api'>
<div class='apiSig'>const   public  trace(options: <a href='ejs-Object.html'>Object</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Configure request tracing for the server.</p>
<dl><dt>Description</dt><dd>The default is to trace the first line of requests and responses at
level 2 and to trace headers at level 3. The options argument contains optional properties: rx and tx 
(for receive and transmit tracing). The rx and tx properties may contain an object hash which describes 
the tracing for that direction and includes any of the following fields:.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>options: <a href='ejs-Object.html'>Object</a> </td><td>Set of trace options with properties "rx" and "tx" for receive and transmit direction tracing. The include property is an array of file extensions to include in tracing. The include property is an array of file extensions to exclude from tracing. The all property specifies that everything for this direction should be traced. The conn property specifies that new connections should be traced. The first property specifies that the first line of the request should be traced. The headers property specifies that the headers (including first line) of the request should be traced. The body property specifies that the body content of the request should be traced. The size property specifies a maximum body size in bytes that will be traced. Content beyond this limit  will not be traced.</td></tr></table></dd>
</dl><dl><dt>Options</dt>
<dd><table class='parameters' summary ='options'>
<td class='param'>transmit.</td><td>Object hash with optional properties: include, exclude, first, headers, body, size.</td></tr>
<td class='param'>receive.</td><td>Object hash with optional properties: include, exclude, conn, first, headers, body, size.</td></tr>
</table></dd>
</dl><dl><dt>Example</dt>
<dd><pre>trace({
    transmit: { exclude: ["gif", "png"], "headers": 3, "body": 4, size: 1000000 }
    receive:  { "conn": 1, "headers": 2 , "body": 4, size: 1024 }
})
</pre></dd></dl>
</div>
</div>
<hr />
<a name='verifyClients'></a>
<div class='api'>
<div class='apiSig'>const   public  verifyClients(caCertPath: <a href='ejs-Path.html'>Path</a>, caCertFile: <a href='ejs-Path.html'>Path</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Verify client certificates.</p>
<dl><dt>Description</dt><dd>This ensures that the clients must provide a client certificate for to verify 
the their identity. You can choose to use either the caCertPath or caCertFile argument. If both are provided
caCertPath takes precedence.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>caCertPath: <a href='ejs-Path.html'>Path</a> </td><td>Defines the directory containing the certificates to use for client authentication. The path may be an absolute path or it may be relative to the ServerRoot. Set to null if you are using <a href='#caCertFile'>caCertFile</a>. </td></tr><tr class='param'><td class='param'>caCertFile: <a href='ejs-Path.html'>Path</a> </td><td>Defines the location of the certificate file or bundle to use for client authentication. Use this if you have a single certificate or a bundle of certificates. Set to null if you are using <a href='#caCertPath'>caCertPath</a>. </td></tr></table></dd>
</dl></div>
</div>
<hr />
<div class="terms">
   <p class="terms">
       <a href="http://www.embedthis.com/">       Embedthis Software LLC, 2003-2011. All rights reserved. Embedthis is a trademark of Embedthis Software LLC.</a>
   </p>
</div></div>
</div>
</body>
</html>
